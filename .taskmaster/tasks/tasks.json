{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up Next.js project with TypeScript and TailwindCSS",
        "description": "Initialize the Next.js project using App Router architecture with TypeScript and TailwindCSS integration for styling.",
        "details": "1. Create a new Next.js project using `npx create-next-app@latest premium-account-marketplace --typescript --tailwind --app`\n2. Configure tsconfig.json with strict type checking\n3. Set up folder structure following App Router conventions:\n   - app/(auth) - for authentication pages\n   - app/(main) - for main application pages\n   - app/api - for API routes\n   - components/ - for reusable UI components\n   - lib/ - for utility functions\n   - types/ - for TypeScript interfaces\n4. Install additional dependencies: `npm install @heroicons/react clsx class-variance-authority`\n5. Configure TailwindCSS with Vietnamese-friendly font stack (e.g., adding Noto Sans Vietnamese)\n6. Set up ESLint and Prettier for code quality\n7. Create basic layout.tsx with header and footer components",
        "testStrategy": "1. Verify project builds without errors using `npm run build`\n2. Test responsive layout on mobile and desktop viewports\n3. Ensure TypeScript is properly configured with no type errors\n4. Validate TailwindCSS is working by testing a sample component",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Vietnamese localization with next-i18next",
        "description": "Set up internationalization support with next-i18next, focusing on Vietnamese as the primary language with English fallback.",
        "details": "1. Install required packages: `npm install next-i18next`\n2. Create localization directory structure:\n   - public/locales/vi/common.json\n   - public/locales/en/common.json\n3. Configure next-i18next in next.config.js:\n```js\nconst { i18n } = require('./next-i18next.config.js');\n\nmodule.exports = {\n  i18n,\n}\n```\n4. Create next-i18next.config.js:\n```js\nmodule.exports = {\n  i18n: {\n    defaultLocale: 'vi',\n    locales: ['vi', 'en'],\n    localeDetection: true,\n  },\n}\n```\n5. Create translation utility hooks in lib/i18n.ts\n6. Implement translation files for common UI elements, product listings, checkout flow, and error messages\n7. Set up middleware.ts to handle locale detection and routing\n<info added on 2025-08-05T05:39:11.979Z>\n8. Implementation Notes:\n   - Website is currently running with Vietnamese content\n   - Need to convert remaining hardcoded text to use translation system\n   - Research indicates next-intl is recommended over next-i18next for Next.js 14 App Router\n   - Current implementation with next-i18next is functional\n   - Complete this task as specified with next-i18next\n   - Create a future task to migrate to next-intl for better App Router compatibility and performance\n\n9. Final Steps:\n   - Identify all remaining hardcoded text in components\n   - Replace with translation keys\n   - Verify all user-facing content is properly internationalized\n   - Document any known limitations with current implementation\n</info added on 2025-08-05T05:39:11.979Z>",
        "testStrategy": "1. Verify all static text is loaded from translation files\n2. Test locale switching (for future enhancement)\n3. Ensure Vietnamese characters display correctly\n4. Validate that all user-facing text is properly translated\n5. Test fallback to English when Vietnamese translation is missing",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Set up authentication with NextAuth.js",
        "description": "Implement user authentication system with email/password and Google OAuth support using NextAuth.js.",
        "details": "1. Install NextAuth.js: `npm install next-auth@latest`\n2. Configure NextAuth.js API route in app/api/auth/[...nextauth]/route.ts\n3. Set up Google OAuth provider:\n```typescript\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\nimport CredentialsProvider from 'next-auth/providers/credentials';\n\nexport const authOptions = {\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n    }),\n    CredentialsProvider({\n      // Email/password implementation\n    })\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.role = user.role;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      session.user.role = token.role;\n      return session;\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    error: '/auth/error',\n  },\n  session: {\n    strategy: 'jwt',\n  },\n};\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\n4. Create authentication middleware to protect routes\n5. Implement sign-in and sign-up pages with Vietnamese UI\n6. Set up user session management and role-based access control\n7. Create environment variables for auth configuration (.env.local)",
        "testStrategy": "1. Test user registration flow\n2. Verify Google OAuth login process\n3. Test email/password authentication\n4. Validate protected routes are properly secured\n5. Ensure user roles (admin/user) are correctly assigned and persisted\n6. Test authentication error handling and messages in Vietnamese",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Set up database with Prisma ORM and PostgreSQL",
        "description": "Configure database connection using Prisma ORM with PostgreSQL and define data models for users, products, carts, orders, and account deliveries.",
        "details": "1. Install Prisma: `npm install prisma @prisma/client`\n2. Initialize Prisma: `npx prisma init`\n3. Configure PostgreSQL connection in .env file\n4. Define Prisma schema in prisma/schema.prisma:\n```prisma\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  password  String?\n  role      String   @default(\"user\")\n  language  String   @default(\"vi\")\n  createdAt DateTime @default(now())\n  carts     Cart[]\n  orders    Order[]\n}\n\nmodel Product {\n  id          String  @id @default(cuid())\n  name        String\n  category    String\n  description String\n  price       Float\n  stock       Int\n  image_url   String\n  CartItem    CartItem[]\n  OrderItem   OrderItem[]\n}\n\nmodel Cart {\n  id        String     @id @default(cuid())\n  userId    String\n  user      User       @relation(fields: [userId], references: [id])\n  items     CartItem[]\n  updatedAt DateTime   @updatedAt\n}\n\nmodel CartItem {\n  id        String  @id @default(cuid())\n  cartId    String\n  cart      Cart    @relation(fields: [cartId], references: [id])\n  productId String\n  product   Product @relation(fields: [productId], references: [id])\n  quantity  Int     @default(1)\n}\n\nmodel Order {\n  id             String           @id @default(cuid())\n  userId         String\n  user           User             @relation(fields: [userId], references: [id])\n  items          OrderItem[]\n  total          Float\n  status         String\n  paidAt         DateTime?\n  accountDelivery AccountDelivery?\n  createdAt      DateTime         @default(now())\n}\n\nmodel OrderItem {\n  id        String  @id @default(cuid())\n  orderId   String\n  order     Order   @relation(fields: [orderId], references: [id])\n  productId String\n  product   Product @relation(fields: [productId], references: [id])\n  quantity  Int     @default(1)\n  price     Float\n}\n\nmodel AccountDelivery {\n  id             String   @id @default(cuid())\n  orderId        String   @unique\n  order          Order    @relation(fields: [orderId], references: [id])\n  credentials    String\n  deliveryStatus String\n  sentAt         DateTime?\n}\n```\n5. Create database migration: `npx prisma migrate dev --name init`\n6. Generate Prisma client: `npx prisma generate`\n7. Create database utility in lib/db.ts for singleton client instance",
        "testStrategy": "1. Verify database connection\n2. Test model relationships with sample data\n3. Validate constraints and default values\n4. Test database migrations\n5. Ensure proper error handling for database operations\n6. Verify Prisma client is properly initialized as a singleton",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement product listing and detail pages",
        "description": "Create product listing page with filters and individual product detail pages using Next.js dynamic routing and server-side rendering for SEO optimization.",
        "details": "1. Create product listing page at app/(main)/products/page.tsx using Server Components\n2. Implement product fetching from database using Prisma client\n3. Design responsive product grid with TailwindCSS:\n```tsx\nexport default async function ProductsPage() {\n  const products = await prisma.product.findMany();\n  \n  return (\n    <div className=\"container mx-auto py-8\">\n      <h1 className=\"text-2xl font-bold mb-6\">Các tài khoản premium</h1>\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6\">\n        {products.map((product) => (\n          <ProductCard key={product.id} product={product} />\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n4. Create product detail page at app/(main)/products/[id]/page.tsx\n5. Implement dynamic routing with product ID parameter\n6. Add product filtering by category\n7. Implement product search functionality\n8. Create reusable ProductCard component\n9. Add \"Add to Cart\" button with quantity selector\n10. Ensure all text is properly translated using next-i18next\n<info added on 2025-08-05T09:11:39.401Z>\n## Implementation Status Update\n\n### Completed Components and Features\n\n#### Products Listing Page\n- Implemented database fetching with Prisma replacing hardcoded data\n- Added category filtering and search functionality with URL-based parameters\n- Created responsive grid layout with proper empty state handling\n\n#### ProductCard Component\n- Developed responsive design with hover effects and stock status indicators\n- Implemented category badges and Vietnamese price formatting\n- Added cart integration with loading states\n- Created product detail page linking\n\n#### ProductFilters Component\n- Built search functionality with form submission\n- Implemented category filtering with active state indicators\n- Added URL-based filtering with searchParams\n- Created responsive mobile-first design\n\n#### Product Detail Page\n- Implemented dynamic routing with product ID parameter\n- Added SEO metadata generation\n- Created breadcrumb navigation and product information display\n- Implemented related products section\n- Added error handling for invalid product IDs\n\n#### AddToCartButton Component\n- Built quantity selector with validation\n- Implemented loading states and success feedback\n- Added disabled state for out-of-stock products\n- Prepared for API integration\n\n#### Technical Implementation\n- Used TypeScript with proper interface definitions\n- Followed Next.js App Router patterns\n- Implemented Server Components for performance optimization\n- Used Client Components for interactive elements\n- Integrated Prisma for database queries\n- Optimized for SEO with metadata\n- Added Vietnamese language support\n- Implemented accessibility features\n\n#### Testing Results\n- All components render correctly\n- Responsive design works across all screen sizes\n- Database integration successful\n- Dynamic routing functional\n- No linting errors\n</info added on 2025-08-05T09:11:39.401Z>",
        "testStrategy": "1. Test product listing page renders correctly\n2. Verify product detail page loads with correct data\n3. Test responsive layout on different screen sizes\n4. Validate product filtering and search functionality\n5. Test \"Add to Cart\" functionality\n6. Verify SEO metadata is properly generated\n7. Test error handling for invalid product IDs",
        "priority": "high",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement shopping cart functionality",
        "description": "Create shopping cart functionality with React Context or Zustand for state management, allowing users to add, remove, and update items.",
        "details": "1. Install Zustand: `npm install zustand`\n2. Create cart store in lib/stores/cartStore.ts:\n```typescript\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\ntype CartItem = {\n  id: string;\n  productId: string;\n  name: string;\n  price: number;\n  quantity: number;\n  imageUrl: string;\n};\n\ntype CartStore = {\n  items: CartItem[];\n  addItem: (item: Omit<CartItem, 'id'>) => void;\n  removeItem: (id: string) => void;\n  updateQuantity: (id: string, quantity: number) => void;\n  clearCart: () => void;\n  totalItems: () => number;\n  totalPrice: () => number;\n};\n\nexport const useCartStore = create<CartStore>(\n  persist(\n    (set, get) => ({\n      items: [],\n      addItem: (item) => {\n        const items = get().items;\n        const existingItem = items.find((i) => i.productId === item.productId);\n        \n        if (existingItem) {\n          return get().updateQuantity(existingItem.id, existingItem.quantity + item.quantity);\n        }\n        \n        set({ items: [...items, { ...item, id: Date.now().toString() }] });\n      },\n      removeItem: (id) => set({ items: get().items.filter((item) => item.id !== id) }),\n      updateQuantity: (id, quantity) => {\n        set({\n          items: get().items.map((item) =>\n            item.id === id ? { ...item, quantity } : item\n          ),\n        });\n      },\n      clearCart: () => set({ items: [] }),\n      totalItems: () => get().items.reduce((total, item) => total + item.quantity, 0),\n      totalPrice: () => get().items.reduce((total, item) => total + item.price * item.quantity, 0),\n    }),\n    { name: 'cart-storage' }\n  )\n);\n```\n3. Create CartPage component at app/(main)/cart/page.tsx\n4. Implement CartItem component for individual items\n5. Add quantity adjustment controls\n6. Create cart summary with total calculation\n7. Add \"Proceed to Checkout\" button\n8. Implement cart badge in header showing item count\n9. Add animations for adding/removing items\n10. Ensure all cart text is properly translated",
        "testStrategy": "1. Test adding items to cart\n2. Verify updating item quantities\n3. Test removing items from cart\n4. Validate cart persistence across page refreshes\n5. Test cart total calculation\n6. Verify cart badge updates correctly\n7. Test cart with multiple items\n8. Validate empty cart state",
        "priority": "high",
        "dependencies": [
          1,
          2,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement checkout and payment integration",
        "description": "Create checkout flow with Stripe integration for payment processing, including order creation and payment confirmation.",
        "details": "1. Install Stripe: `npm install stripe @stripe/stripe-js`\n2. Set up Stripe API keys in .env.local\n3. Create checkout page at app/(main)/checkout/page.tsx\n4. Implement order summary component\n5. Create shipping/billing information form\n6. Set up Stripe Elements for secure payment:\n```typescript\nimport { loadStripe } from '@stripe/stripe-js';\nimport { Elements, PaymentElement, useStripe, useElements } from '@stripe/react-stripe-js';\n\nconst stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY);\n\nexport default function CheckoutPage() {\n  const [clientSecret, setClientSecret] = useState('');\n  \n  useEffect(() => {\n    // Create PaymentIntent on component mount\n    fetch('/api/create-payment-intent', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ items: cartItems, total: cartTotal }),\n    })\n      .then((res) => res.json())\n      .then((data) => setClientSecret(data.clientSecret));\n  }, []);\n  \n  return (\n    <div className=\"container mx-auto py-8\">\n      <h1 className=\"text-2xl font-bold mb-6\">Thanh toán</h1>\n      {clientSecret && (\n        <Elements stripe={stripePromise} options={{ clientSecret }}>\n          <CheckoutForm />\n        </Elements>\n      )}\n    </div>\n  );\n}\n```\n7. Create API route for payment intent at app/api/create-payment-intent/route.ts\n8. Implement webhook handler for payment confirmation at app/api/webhooks/stripe/route.ts\n9. Create order in database after successful payment\n10. Implement payment success and error pages\n11. Add VNPay integration as alternative payment method",
        "testStrategy": "1. Test checkout flow end-to-end\n2. Verify Stripe Elements loads correctly\n3. Test payment processing with test cards\n4. Validate webhook handling for payment confirmation\n5. Test order creation in database\n6. Verify payment success and error pages\n7. Test form validation for shipping/billing information\n8. Validate VNPay integration",
        "priority": "high",
        "dependencies": [
          4,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create user dashboard",
        "description": "Implement user dashboard for viewing order history, account credentials, and managing profile information.",
        "details": "1. Create dashboard layout at app/(dashboard)/dashboard/layout.tsx\n2. Implement dashboard navigation with sidebar\n3. Create order history page at app/(dashboard)/dashboard/orders/page.tsx:\n```typescript\nexport default async function OrdersPage() {\n  const session = await getServerSession(authOptions);\n  if (!session) redirect('/auth/signin');\n  \n  const orders = await prisma.order.findMany({\n    where: { userId: session.user.id },\n    include: {\n      items: {\n        include: { product: true }\n      },\n      accountDelivery: true\n    },\n    orderBy: { createdAt: 'desc' }\n  });\n  \n  return (\n    <div>\n      <h1 className=\"text-2xl font-bold mb-6\">Lịch sử đơn hàng</h1>\n      {orders.length === 0 ? (\n        <p>Bạn chưa có đơn hàng nào.</p>\n      ) : (\n        <div className=\"space-y-6\">\n          {orders.map((order) => (\n            <OrderCard key={order.id} order={order} />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n4. Create account credentials page at app/(dashboard)/dashboard/credentials/page.tsx\n5. Implement profile management page\n6. Add order detail view with credential access\n7. Create reusable OrderCard component\n8. Implement loading and error states\n9. Add pagination for order history",
        "testStrategy": "1. Test dashboard access control\n2. Verify order history displays correctly\n3. Test credential viewing functionality\n4. Validate profile management features\n5. Test responsive layout on different screen sizes\n6. Verify loading and error states\n7. Test pagination for order history\n8. Validate all text is properly translated",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement admin dashboard",
        "description": "Create admin dashboard for managing products, orders, and user accounts with role-based access control.",
        "details": "1. Create admin layout at app/(admin)/admin/layout.tsx with role-based middleware protection\n2. Implement admin navigation with sidebar\n3. Create product management page at app/(admin)/admin/products/page.tsx\n4. Implement product CRUD operations:\n   - Create product form\n   - Edit product form\n   - Delete product confirmation\n   - Product list with filtering and search\n5. Create order management page at app/(admin)/admin/orders/page.tsx\n6. Implement order status updates and credential delivery\n7. Add user management page for viewing and managing user accounts\n8. Create dashboard overview with key metrics\n9. Implement server actions for database operations:\n```typescript\n'use server'\n\nexport async function createProduct(formData: FormData) {\n  const name = formData.get('name') as string;\n  const category = formData.get('category') as string;\n  const description = formData.get('description') as string;\n  const price = parseFloat(formData.get('price') as string);\n  const stock = parseInt(formData.get('stock') as string);\n  const image_url = formData.get('image_url') as string;\n  \n  return prisma.product.create({\n    data: {\n      name,\n      category,\n      description,\n      price,\n      stock,\n      image_url\n    }\n  });\n}\n```",
        "testStrategy": "1. Test admin access control\n2. Verify product CRUD operations\n3. Test order management functionality\n4. Validate user management features\n5. Test dashboard metrics accuracy\n6. Verify form validation for product creation/editing\n7. Test responsive layout on different screen sizes\n8. Validate all text is properly translated",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement account credential delivery system",
        "description": "Create system for delivering premium account credentials to users after successful payment, with both manual and automated options.",
        "details": "1. Create AccountDelivery model in database (already defined in Prisma schema)\n2. Implement credential management interface in admin dashboard\n3. Create credential delivery form for manual delivery:\n```typescript\nexport function CredentialDeliveryForm({ orderId }: { orderId: string }) {\n  const [credentials, setCredentials] = useState('');\n  \n  async function handleSubmit(formData: FormData) {\n    'use server'\n    \n    const credentials = formData.get('credentials') as string;\n    \n    await prisma.accountDelivery.create({\n      data: {\n        orderId,\n        credentials,\n        deliveryStatus: 'delivered',\n        sentAt: new Date()\n      }\n    });\n    \n    await prisma.order.update({\n      where: { id: orderId },\n      data: { status: 'completed' }\n    });\n  }\n  \n  return (\n    <form action={handleSubmit}>\n      <textarea \n        name=\"credentials\" \n        value={credentials}\n        onChange={(e) => setCredentials(e.target.value)}\n        placeholder=\"Nhập thông tin tài khoản (username, password, etc.)\"\n        className=\"w-full p-2 border rounded\"\n        rows={4}\n      />\n      <button type=\"submit\" className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded\">\n        Gửi thông tin tài khoản\n      </button>\n    </form>\n  );\n}\n```\n4. Add credential viewing interface in user dashboard\n5. Implement credential encryption for security\n6. Create notification system for new credential delivery\n7. Add automated delivery option based on predefined templates\n8. Implement delivery status tracking",
        "testStrategy": "1. Test manual credential delivery\n2. Verify credential viewing in user dashboard\n3. Test credential encryption and security\n4. Validate notification system\n5. Test automated delivery option\n6. Verify delivery status tracking\n7. Test error handling for delivery failures\n8. Validate all text is properly translated",
        "priority": "medium",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement VNPay/Momo payment integration",
        "description": "Add Vietnamese payment methods (VNPay and Momo) as alternatives to Stripe for local users.",
        "details": "1. Register developer accounts with VNPay and Momo\n2. Install necessary SDKs: `npm install vnpay-nodejs momo-payment-sdk`\n3. Set up API keys in .env.local\n4. Create payment method selection interface in checkout\n5. Implement VNPay integration:\n```typescript\n// app/api/vnpay/create-payment/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport vnpay from 'vnpay-nodejs';\n\nexport async function POST(request: NextRequest) {\n  const { amount, orderId } = await request.json();\n  \n  const vnp_TxnRef = orderId;\n  const vnp_Amount = amount * 100; // Convert to smallest currency unit\n  const vnp_ReturnUrl = `${process.env.NEXT_PUBLIC_APP_URL}/checkout/result`;\n  \n  const vnpayParams = {\n    vnp_Version: '2.1.0',\n    vnp_Command: 'pay',\n    vnp_TmnCode: process.env.VNPAY_TMN_CODE,\n    vnp_Amount: vnp_Amount,\n    vnp_CreateDate: new Date().toISOString(),\n    vnp_CurrCode: 'VND',\n    vnp_IpAddr: request.ip || '127.0.0.1',\n    vnp_Locale: 'vn',\n    vnp_OrderInfo: `Thanh toan don hang ${orderId}`,\n    vnp_OrderType: 'billpayment',\n    vnp_ReturnUrl: vnp_ReturnUrl,\n    vnp_TxnRef: vnp_TxnRef,\n  };\n  \n  const paymentUrl = vnpay.buildPaymentUrl(vnpayParams, process.env.VNPAY_HASH_SECRET);\n  \n  return NextResponse.json({ paymentUrl });\n}\n```\n6. Implement Momo integration\n7. Create payment result handling for both providers\n8. Add webhook handlers for payment notifications\n9. Implement payment status checking and order updates",
        "testStrategy": "1. Test VNPay payment flow in sandbox environment\n2. Verify Momo payment integration\n3. Test payment result handling\n4. Validate webhook processing\n5. Test payment status checking\n6. Verify order updates after payment\n7. Test error handling for failed payments\n8. Validate all text is properly translated",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement real-time notifications",
        "description": "Create real-time notification system for order updates, payment confirmations, and credential delivery using WebSockets.",
        "details": "1. Install Pusher: `npm install pusher pusher-js`\n2. Set up Pusher credentials in .env.local\n3. Create notification utility in lib/notifications.ts:\n```typescript\nimport Pusher from 'pusher';\n\nexport const pusher = new Pusher({\n  appId: process.env.PUSHER_APP_ID!,\n  key: process.env.NEXT_PUBLIC_PUSHER_KEY!,\n  secret: process.env.PUSHER_SECRET!,\n  cluster: process.env.PUSHER_CLUSTER!,\n  useTLS: true,\n});\n\nexport function triggerNotification(channel: string, event: string, data: any) {\n  return pusher.trigger(channel, event, data);\n}\n```\n4. Create notification component for displaying alerts\n5. Implement notification subscription in layout:\n```typescript\n'use client'\n\nimport { useEffect, useState } from 'react';\nimport Pusher from 'pusher-js';\nimport { useSession } from 'next-auth/react';\n\nexport function NotificationListener() {\n  const { data: session } = useSession();\n  const [notifications, setNotifications] = useState([]);\n  \n  useEffect(() => {\n    if (!session?.user?.id) return;\n    \n    const pusher = new Pusher(process.env.NEXT_PUBLIC_PUSHER_KEY!, {\n      cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,\n    });\n    \n    const channel = pusher.subscribe(`user-${session.user.id}`);\n    \n    channel.bind('new-notification', (data) => {\n      setNotifications((prev) => [data, ...prev]);\n    });\n    \n    return () => {\n      pusher.unsubscribe(`user-${session.user.id}`);\n    };\n  }, [session]);\n  \n  return (\n    <div className=\"fixed bottom-4 right-4 z-50\">\n      {notifications.map((notification, index) => (\n        <div key={index} className=\"bg-white shadow-lg rounded-lg p-4 mb-2 max-w-sm\">\n          <h3 className=\"font-bold\">{notification.title}</h3>\n          <p>{notification.message}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n6. Trigger notifications for key events:\n   - Order status changes\n   - Payment confirmations\n   - Credential delivery\n   - Admin actions\n7. Implement notification preferences in user settings",
        "testStrategy": "1. Test notification triggering\n2. Verify notification display in UI\n3. Test real-time updates\n4. Validate notification persistence\n5. Test notification preferences\n6. Verify notifications work across different devices\n7. Test error handling for notification failures\n8. Validate all text is properly translated",
        "priority": "low",
        "dependencies": [
          8,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement analytics and monitoring",
        "description": "Set up analytics and error monitoring using Sentry and LogRocket to track user behavior and application errors.",
        "details": "1. Install Sentry: `npm install @sentry/nextjs`\n2. Install LogRocket: `npm install logrocket`\n3. Configure Sentry in next.config.js and create sentry.client.config.js and sentry.server.config.js\n4. Set up LogRocket in app/layout.tsx:\n```typescript\n'use client'\n\nimport { useEffect } from 'react';\nimport LogRocket from 'logrocket';\n\nexport function AnalyticsProvider({ children }: { children: React.ReactNode }) {\n  useEffect(() => {\n    LogRocket.init(process.env.NEXT_PUBLIC_LOGROCKET_APP_ID!);\n  }, []);\n  \n  return <>{children}</>;\n}\n```\n5. Create custom error boundary component\n6. Implement user identification for both tools\n7. Set up performance monitoring\n8. Create admin analytics dashboard with key metrics:\n   - Conversion rate\n   - Popular products\n   - Payment method usage\n   - User acquisition channels\n9. Implement event tracking for key user actions",
        "testStrategy": "1. Test error capturing with Sentry\n2. Verify session recording with LogRocket\n3. Test custom error boundary\n4. Validate user identification\n5. Test performance monitoring\n6. Verify analytics dashboard data\n7. Test event tracking\n8. Validate error reporting in production environment",
        "priority": "low",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement search and filtering functionality",
        "description": "Create advanced search and filtering capabilities for products, including category filters, price range, and text search.",
        "details": "1. Create search component in app/(main)/products/components/SearchFilters.tsx\n2. Implement server-side search API at app/api/search/route.ts:\n```typescript\nimport { NextRequest, NextResponse } from 'next/server';\nimport { prisma } from '@/lib/db';\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const query = searchParams.get('q') || '';\n  const category = searchParams.get('category');\n  const minPrice = searchParams.get('minPrice') ? parseFloat(searchParams.get('minPrice')!) : undefined;\n  const maxPrice = searchParams.get('maxPrice') ? parseFloat(searchParams.get('maxPrice')!) : undefined;\n  \n  const products = await prisma.product.findMany({\n    where: {\n      AND: [\n        { name: { contains: query, mode: 'insensitive' } },\n        category ? { category } : {},\n        minPrice ? { price: { gte: minPrice } } : {},\n        maxPrice ? { price: { lte: maxPrice } } : {}\n      ]\n    },\n    orderBy: { name: 'asc' }\n  });\n  \n  return NextResponse.json({ products });\n}\n```\n3. Create filter components:\n   - Category filter\n   - Price range slider\n   - Sort options\n4. Implement client-side filtering with React useState and useEffect\n5. Add URL parameter synchronization for shareable filtered views\n6. Create loading states for search results\n7. Implement pagination for search results\n8. Add search history for users",
        "testStrategy": "1. Test search functionality with various queries\n2. Verify category filtering\n3. Test price range filtering\n4. Validate sort options\n5. Test URL parameter synchronization\n6. Verify loading states\n7. Test pagination\n8. Validate search history functionality\n9. Test performance with large result sets",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement deployment and CI/CD pipeline",
        "description": "Set up deployment configuration for Vercel and implement CI/CD pipeline with GitHub Actions for automated testing and deployment.",
        "details": "1. Create vercel.json configuration:\n```json\n{\n  \"version\": 2,\n  \"builds\": [\n    { \"src\": \"package.json\", \"use\": \"@vercel/next\" }\n  ],\n  \"routes\": [\n    { \"src\": \"/(.*)\", \"dest\": \"/\" }\n  ],\n  \"env\": {\n    \"DATABASE_URL\": \"@database_url\",\n    \"NEXTAUTH_URL\": \"@nextauth_url\",\n    \"NEXTAUTH_SECRET\": \"@nextauth_secret\",\n    \"GOOGLE_CLIENT_ID\": \"@google_client_id\",\n    \"GOOGLE_CLIENT_SECRET\": \"@google_client_secret\",\n    \"STRIPE_SECRET_KEY\": \"@stripe_secret_key\",\n    \"STRIPE_WEBHOOK_SECRET\": \"@stripe_webhook_secret\",\n    \"NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY\": \"@next_public_stripe_publishable_key\"\n  }\n}\n```\n2. Set up GitHub Actions workflow in .github/workflows/ci.yml:\n```yaml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18.x'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run linting\n        run: npm run lint\n      - name: Run tests\n        run: npm test\n\n  deploy:\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to Vercel\n        uses: amondnet/vercel-action@v20\n        with:\n          vercel-token: ${{ secrets.VERCEL_TOKEN }}\n          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}\n          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}\n          vercel-args: '--prod'\n```\n3. Configure environment variables in Vercel dashboard\n4. Set up database connection for production\n5. Configure domain and SSL\n6. Implement database migration in deployment pipeline\n7. Set up monitoring and alerting\n8. Create backup and disaster recovery plan",
        "testStrategy": "1. Test deployment to staging environment\n2. Verify CI/CD pipeline execution\n3. Test database migrations\n4. Validate environment variables\n5. Test SSL configuration\n6. Verify domain setup\n7. Test monitoring and alerting\n8. Validate backup and recovery procedures\n9. Test application performance in production environment",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-05T04:26:40.630Z",
      "updated": "2025-08-05T09:04:54.354Z",
      "description": "Tasks for master context"
    }
  }
}